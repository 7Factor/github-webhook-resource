#!/usr/bin/env node
'use strict'

const fetch = require('node-fetch');
const env = process.env;
const stdin = process.stdin;

stdin.setEncoding('utf8');

let inputChunks = [];
stdin.on('data', function (chunk) {
    inputChunks.push(chunk);
});

stdin.on('end', function () {
    let inputJSON = inputChunks.join("");

    let parsedData;
    try {
        parsedData = JSON.parse(inputJSON);
    } catch(error) {
        logInfo('Error:', error.stack);
        process.exit(1);
    }

    validateInput(parsedData);

    const source = parsedData.source || {};
    const params = parsedData.params || {};

    const githubApi = source.github_api; 
    const githubToken = source.github_token;
    const org = params.org;
    const repo = params.repo;
    const githubUrl = `${githubApi}/repos/${org}/${repo}/hooks`;

    const operation = params.operation.toLowerCase();
    const resourceName = params.resource_name;
    const webhookToken = params.webhook_token;
    doWork(githubUrl, githubToken, operation, resourceName, webhookToken);
});

async function doWork(githubUrl, githubToken, operation, resourceName, webhookToken) {
    logInfo(`Using githubUrl: ${githubUrl}`);

    let url = `${env.ATC_EXTERNAL_URL}/teams/${env.BUILD_TEAM_NAME}/pipelines/${env.BUILD_PIPELINE_NAME}/resources/${resourceName}/check/webhook?webhook_token=${webhookToken}`;
    let urlLower = url.toLowerCase();
    let uri = encodeURI(urlLower);
    logInfo(`Setting Github webhook for ${uri}`);

    let config = { 
        'url': uri,
        'content-type': 'json'
    };
    
    let body = {
        'name': 'web',  // NOTE: Github will deprecated this field soon
        'config': config
    };

    const existingHooks = async () => {
        const response = await callGithub(githubUrl, 'GET', githubToken);
        if (response.ok) {
            const json = await response.json();
            return json;
        } else {
            logInfo(`Error from Github: Response Status: ${response.status} Response Status Text: ${response.statusText}`);
            process.exit(1);
        }
    };

    const existingHookList = await existingHooks();
    const existingHook = existingHookList.find(hook => hook.config.url == uri);

    switch (operation) {
        case 'create':
            if (existingHook != null) {
                logInfo('Webhook already exists');
                emit(existingHook);
            } else {
                createWebhook(githubUrl, 'POST', githubToken, body);
            }
            break;
        case 'delete':
            if (existingHook != null) {
                const deleteUri = `${githubUrl}/${existingHook.id}`;
                await callGithub(deleteUri, 'DELETE', githubToken);
                logInfo('Webhook deleted successfully');
                emit(existingHook);
            } else {
                logInfo('Webhook does not exist');
                emit({id: Date.now()});
            }
            break;
    }
}

function createWebhook(githubUrl, method, githubToken, body) {
    const bodyString = JSON.stringify(body);
    logInfo(`Fetching with request body: ${bodyString}`);
    
    const response = callGithub(githubUrl, method, githubToken, bodyString);
    response.then(res => {
        if (res.ok) {
            res.json().then(response => {
                logInfo(`Success: ${JSON.stringify(response)}`);
                emit(response);
            });
        } else {
            throw new Error(`Error from Github: Response Status: ${res.status} Response Status Text: ${res.statusText} \n Request Body: ${bodyString}`);
        }
    })
    .catch(error => {
        logInfo(error.stack);
        process.exit(1);
    });
}

function callGithub(githubUrl, method, githubToken, body) {
    return fetch(githubUrl, {
        method: method,
        body: body,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `token ${githubToken}`
        }
    })
}

function emit(result) {
    let output = {
        version: {
            id: result.id.toString()
        }
    }
    logInfo(`Output: ${JSON.stringify(output)}`);
    console.log(JSON.stringify(output, null, 2));
    process.exit(0);
}

function logInfo(message) {
    console.error(message);
}

function validateInput(parsedData) {
    const source = parsedData.source;
    const params = parsedData.params;
    const validOperations = ['create', 'delete'];
    
    let isValid = true;
    isValid = validateItem(parsedData, 'source', 'github_api', isValid);
    isValid = validateItem(parsedData, 'source', 'github_token', isValid);
    isValid = validateItem(process, 'env', 'ATC_EXTERNAL_URL', isValid);
    isValid = validateItem(process, 'env', 'BUILD_TEAM_NAME', isValid);
    isValid = validateItem(process, 'env', 'BUILD_PIPELINE_NAME', isValid);
    isValid = validateItem(parsedData, 'params', 'org', isValid);
    isValid = validateItem(parsedData, 'params', 'repo', isValid);
    isValid = validateItem(parsedData, 'params', 'resource_name', isValid);
    isValid = validateItem(parsedData, 'params', 'webhook_token', isValid);
    isValid = validateItem(parsedData, 'params', 'operation', isValid);
    
    if (parsedData['params'].operation && !validOperations.includes(parsedData['params'].operation.toLowerCase())) {
        console.error(`Unsupported operation: ${params.operation}`);
        isValid = false;
    }

    if (!isValid) process.exit(1);
}

function validateItem(configObject, config, property, validState) {

    if (!configObject[config][property]) {
        console.error(`Invalid configuration: ${config}.${property} is required`);
        return false;
    } else {
        return validState;
    }
}