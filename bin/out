#!/usr/bin/env node
'use strict'

const fetch = require('node-fetch');
const env = process.env;
const stdin = process.stdin;

stdin.setEncoding('utf8');

let inputChunks = [];
stdin.on('data', function (chunk) {
    inputChunks.push(chunk);
});

stdin.on('end', function () {
    let inputJSON = inputChunks.join("");
    logInfo(`Received stdin: ${inputJSON}`);

    let parsedData;
    try {
        parsedData = JSON.parse(inputJSON);
    } catch(error) {
        logInfo('Error:', error.stack);
        process.exit(1);
    }

    let source = parsedData.source || {};
    let params = parsedData.params || {};

    validateInput(source, params);

    let githubApi = source.github_api; 
    let githubToken = source.github_token;
    let org = params.org;
    let repo = params.repo;
    let githubUrl = `${githubApi}/repos/${org}/${repo}/hooks`;

    let operation = params.operation.toLowerCase();
    let resourceName = params.resource_name;
    let webhookToken = params.webhook_token;
    doWork(githubUrl, githubToken, operation, resourceName, webhookToken);
});

async function doWork(githubUrl, githubToken, operation, resourceName, webhookToken) {
    logInfo(`Using githubUrl: ${githubUrl}`);

    let url = `${env.ATC_EXTERNAL_URL}/teams/${env.BUILD_TEAM_NAME}/pipelines/${env.BUILD_PIPELINE_NAME}/resources/${resourceName}/check/webhook?webhook_token=${webhookToken}`;
    let urlLower = url.toLowerCase();
    let uri = encodeURI(urlLower);
    logInfo(`Setting Github webhook for ${uri}`);

    let config = { 
        'url': uri,
        'content-type': 'json'
    };
    
    let body = {
        'name': 'web',  // NOTE: Github will deprecated this field soon
        'config': config
    };
  
    const existingHooks = async () => {
        const response = await fetch(githubUrl, {
            method: 'GET',
            headers: {
                'Authorization': `token ${githubToken}`
            }
        });
        const json = await response.json();
        return json;
    };

    const existingHookList = await existingHooks();
    const existingHook = existingHookList.find(hook => hook.config.url == uri);

    if(existingHook != null) {
        logInfo('Webhook already exists');
        emit(existingHook);
    } else {
        let bodyString = JSON.stringify(body);
        logInfo(`Fetching with request body: ${bodyString}`);
    
        fetch(githubUrl, {
            method: 'POST',
            body: bodyString,
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `token ${githubToken}`
            }
        }).then(res => {
            if (res.ok) {
                res.json().then(response => {
                    logInfo(`Success: ${JSON.stringify(response)}`);
                    emit(response);
                });
            } else {
                throw new Error(`Response Status: ${res.status} Response Status Text: ${res.statusText} \n Request Body: ${bodyString}`);
            }
        })
        .catch(error => {
            logInfo(error.stack);
            process.exit(1);
        });
    }
}

function emit(result) {
    let output = {
        version: {
            id: result.id.toString()
        }
    }
    logInfo(`Output: ${JSON.stringify(output)}`);
    console.log(JSON.stringify(output, null, 2));
    process.exit(0);
}

function logInfo(message) {
    console.error(message);
}

function validateInput(source, params) {
    let validOperations = ['post'];

    let invalid = false;
    if (source.github_api === undefined)    invalid = inputError('source.github_api');
    if (source.github_token === undefined)  invalid = inputError('source.github_api');
    if (params.org === undefined)           invalid = inputError('params.org');
    if (params.repo === undefined)          invalid = inputError('params.repo');
    if (params.resource_name === undefined) invalid = inputError('params.resource_name');
    if (params.webhook_token === undefined) invalid = inputError('params.webhook_token');
    
    if (params.operation === undefined) {  
        invalid = inputError('params.operation');
    } else if (!validOperations.includes(params.operation.toLowerCase())) {
        invalid = true;
        logInfo(`Unsupported operation: ${params.operation}`);
    }

    if (invalid) process.exit(1);
}

function inputError(param) {
    console.error(`Invalid configuration: ${param} is required`);
    return true;
}